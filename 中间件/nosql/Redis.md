# Redis

Redis是一个开源的,支持网络,基于内存亦可持久化的日志型`键值对`数据库

## 存储方式

### Snapshot

    是将数据先存储在内存,然后当数据累计达到某些设定的伐值的时候,就会触发一次DUMP操作,将变化的数据一次性写入数据文件（RDB文件）.
    
### AOF

    是将数据也是先存在内存,但是在存储的时候会使用调用fsync来完成对本次写操作的日志记录,
    这个日志揭露文件其实是一个基于Redis网络交互协议的文本文件.
    AOF调用fsync也不是说全部都是无阻塞的,
    在某些系统上可能出现fsync阻塞进程的情况,
    对于这种情况可以通过配置修改,但默认情况不要修改.AOF最关键的配置就是关于调用fsync追加日志文件的平率,
    有两种预设频率,always每次记录进来都添加,everysecond每秒添加一次.两个配置各有所长后面分析.
    由于是采用日志追加的方式来持久话数据,所以引出了第二个日志的概念：rewrite.后面介绍它的由来.

### 比较
* 性能
    Snapshot方式的性能是要明显高于AOF方式的，原因有两点：
    * 采用2进制方式存储数据，数据文件比较小，加载快速。
    * 存储的时候是按照配置中的save策略来存储，每次都是聚合很多数据批量存储，写入的效率很好，
    而AOF则一般都是工作在实时存储或者准实时模式下。相对来说存储的频率高，效率却偏低。

* 数据安全
    AOF数据安全性高于Snapshot存储，原因：
    * Snapshot存储是基于累计批量的思想，也就是说在允许的情况下，累计的数据越多那么写入效率也就越高，
        但数据的累计是靠时间的积累完成的，那么如果在长时间数据不写入RDB，
        但Redis又遇到了崩溃，那么没有写入的数据就无法恢复了
    * AOF方式偏偏相反，根据AOF配置的存储频率的策略可以做到最少的数据丢失和较高的数据恢复能力。
        
* Rewrite

    所谓Rewrite就是将日志文件中的所有数据都重新写到另外一个新的日志文件中，但是不同的是，
    对于老日志文件中对于Key的多次操作，
    只保留最终的值的那次操作记录到日志文件中，从而缩小日志文件的大小。这里有两个配置需要注意：
    auto-aof-rewrite-percentage 100 （当前写入日志文件的大小占到初始日志文件大小的某个百分比时触发Rewrite）
    auto-aof-rewrite-min-size 64mb （本次Rewrite最小的写入数据良）


## 数据结构

* String

* Hash

* List

* Set

* Sort Set

## 部署

* 哨兵(Sentinel)

    哨兵模式是一种特殊的模式，
    首先Redis提供了哨兵的命令，
    哨兵是一个独立的进程，作为进程，它会独立运行。
    其原理是哨兵通过发送命令，
    等待Redis服务器响应，从而监控运行的多个Redis实例。
    
    * 哨兵作用:
        1. 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。
        2. 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。
    
    **故障切换(failover)**
    
    假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，
    仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。
    当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，
    那么哨兵之间就会进行一次投票，
    投票的结果由一个哨兵发起，进行failover操作。
    切换成功后，就会通过发布订阅模式，
    让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。
    这样对于客户端而言，一切都是透明的。


* 分区
    分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。
    
    * 分区的优势
        通过利用多台计算机内存的和值，允许我们构造更大的数据库。
        通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。
    * 分区的不足
        redis的一些特性在分区方面表现的不是很好：
        涉及多个key的操作通常是不被支持的。举例来说，当两个set映射到不同的redis实例上时，你就不能对这两个set执行交集操作。
        涉及多个key的redis事务不能使用。
        当使用分区时，数据处理较为复杂，比如你需要处理多个rdb/aof文件，并且从多个实例和主机备份持久化文件。
        增加或删除容量也比较复杂。redis集群大多数支持在运行时增加、删除节点的透明数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然而，一种叫做presharding的技术对此是有帮助的。
        分区类型
    * Redis 有两种类型分区。 
        假设有4个Redis实例 R0，R1，R2，R3，和类似user:1，user:2这样的表示用户的多个key，
        对既定的key有多种不同方式来选择这个key存放在哪个实例中。也就是说，有不同的系统来映射某个key到某个Redis服务。

        1. 范围分区
            最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的Redis实例。
            比如，ID从0到10000的用户会保存到实例R0，ID从10001到 20000的用户会保存到R1，以此类推。
            这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射表。这个表要被管理，同时还需要各 种对象的映射表，通常对Redis来说并非是好的方法。
        2. 哈希分区
            另外一种分区方法是hash分区。这对任何key都适用，也无需是object_name:这种形式，像下面描述的一样简单：
            用一个hash函数将key转换为一个数字，比如使用crc32 hash函数。对key foobar执行crc32(foobar)会输出类似93024922的整数。
            对这个整数取模，将其转化为0-3之间的数字，就可以将这个整数映射到4个Redis实例中的一个了。93024922 % 4 = 2，就是说key foobar应该被存到R2实例中。注意：取模操作是取除的余数，通常在多种编程语言中用%操作符实现。
        3. 环形hash
            求模后往下找,找到某个代表节点的数字,选中该节点
