# Mysql

关系型数据库

## 表类型（存储引擎）的选择

* InnoDB

    InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比与MyISAM的存储引擎，InnoDB写的处理效率 差一些，并且会占用更多地磁盘空间以保留数据和索引。
    InnoDB不同于其他存储引擎的表的特点：
    * 自动增长列：InnoDB表的自动增长列可以手工插入，
        但是如果是插入的值是空或者是0，
        则实际插入的将是自动增长后的值。
        通过`ALTER TABLE *** AUTO_INCREMENT = n`
        语句强制设置自动增长列的初始值，
        默认从1开始，但是该强制的默认值是保留在内存中的，
        如果该值在使用之前数据库重新启动，那么该值会失效。
        **对于InnoDB表，自动增长列是索引，如果是组合索引，也必须是组合索引的第一列**。
    * 外键约束：MySQL支持外键的存储引擎只有InnoDB，在创建外键的时候，要求父表必须有对应的索引，子表在创建外键的时候也会自动创建对应的索引。
    * 聚集索引:InnoDB数据文件是和索引绑在一起的，必须要有主键，
        通过主键索引效率很高。但是辅助索引需要两次查询，
        先查询到主键，然后再通过主键查询到数据。
        因此，主键不应该过大，因为主键太大，其他索引也都会很大。
        而MyISAM是非聚集索引，数据文件是分离的，
        索引保存的是数据文件的`指针`。
        主键索引和辅助索引是独立的。
    * InnoDB不保存表的具体行数
    * Innodb不支持全文索引
    
## 事务隔离级别


隔离级别|脏读(Dirty Read)|不可重复读(NonRepeatable Read)| 幻读(Phantom Read)
----|---|---|---
未提交读(Read uncommitted)|可能|可能|可能
已提交读(Read committed)|不可能|可能|可能
可重复读(Repeatable read)|不可能|不可能|可能
可串行化(Serializable)|不可能	|不可能|	不可能

* 未提交读
    * 允许读取到其他会话中未提交的的内容
* 已提交读
    * 只能读取到已提交的数据
* 可重复读
    * 在同一会话中,对同一资源的查询和事务开始的一刻永远一致
* 可串行化
    * 每一次读写都需要获得表级共享锁,读写互相阻塞
    
* 不可重复读和幻读的区别
    * 不可重复读重点在于update和delete，而幻读的重点在于insert。
    如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。
    所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。

## InnoDB锁机制

* 共享锁(S)
    * 允许一个事务去读,阻止其他事务获取相同数据的排他锁,也就是我读取的行,你不能修改
* 排他锁(X)
    * 允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁,也就是我更新的行,不允许其他的事务读取和更新相同的行.

另外，为了`允许行锁和表锁共存`，实现多粒度锁机制，InnoDB还有两种`内部使用`的意向锁（Intention Locks），这两种意向锁都是表锁。

* 意向共享锁(IS)
    * 事务打算获取`行的共享锁`,则要先获取表的`IS锁`
* 意向排他锁(IX)
    * 事务打算获取`行的排他锁`,则要先获取表的`IX`锁
    
* 获取锁
    * 意向锁InnoDB内部使用和控制,无需用户干预;
    * 对于UPDATE,DELETE,INSERT语句,自动获取排他锁(X);
    * 对于普通SELECT语句，InnoDB不会加任何锁;
    * 事务可以通过以下语句显示给记录集加共享锁(S)或排他锁(X)
        * `SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE` 共享锁(S)
        * `SELECT * FROM table_name WHERE ... FOR UPDATE` 排他锁(X)
        
### 实现原理
* InnoDB行锁是通过给索引上的索引项加锁来实现的,
    这一点MySQL与Oracle不同,
    后者是通过在数据块中对相应数据行加锁来实现的。
    InnoDB这种行锁实现特点意味着:只有通过索引条件检索数据,InnoDB才使用行级锁,否则,
    InnoDB将使用表锁!索引分为主键索引和二级索引两种,
    如果一条sql语句操作了主键索引,MySQL就会锁定这条主键索引;
    如果一条语句操作了二级索引,MySQL会先锁定该二级索引,
    再锁定相关的主键索引。
* innodb行锁分为三种情形
    * Record lock 
        * 对索引项加锁，即锁定一条记录
    * Gap lock
        * 对索引项之间的‘间隙’、对第一条记录前的间隙或最后一条记录后的间隙加锁，即锁定一个范围的记录，不包含记录本身
    * Next-key Lock
        * 锁定一个范围的记录并包含记录本身(上面两者的结合)
**Next-Key Lock是行锁与间隙锁的组合，这样，当InnoDB扫描索引记录的时候，会首先对选中的索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。如果一个间隙被事务T1加了锁，其它事务是不能在这个间隙插入记录的**

### 注意事项
* InnoDB行锁是通过给索引项加锁实现的，如果没有索引，InnoDB会通过隐藏的聚簇索引来对记录加锁。也就是说：如果不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果跟表锁一样。
* 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，
    但是如果是使用相同的索引键，是会出现锁冲突的。说白了就是，
    where id=1 for update 
    会锁定所有id=1的数据行，
    如果是where id=1 and name='liuwenhe' for update,
    这样会把所有 id=1以及所有name='liuwenhe'的行都上排它锁；
* 当表有多个索引的时候，不同的事务可以使用`不同的索引`锁定`不同的行`，
    另外，不论是使用主键索引、唯一索引或普通索引，
    InnoDB都会使用行锁来对数据加锁。
* 即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL优化器通过
    判断不同执行计划的代价来决定的，
    如果MySQL认为**`全表扫描`效率`更高`**，比如对一些很小的表，
    它就不会使用索引，或者饮食转换，或者like百分号在前等等，
    这种情况下InnoDB将**`使用表锁`**，而不是行锁。
    因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。

### 死锁

* MyISAM表锁是deadlock free的，这是因为MyISAM总是一次获得所需的全部锁，
    要么全部满足，要么等待，
    因此不会出现死锁。
    但在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，
    这就决定了在InnoDB中发生死锁是可能的。
    *先获取A的锁,然后获取B的锁,另外的事务,先获取B再获取A*
* 解决方案
    * 超时参数 `innodb_lock_wait_timeout`
    * 保证对资源访问的顺序一致,避免A->B与B->A的情况
    
    

            
    
    
    
    

    
    



    